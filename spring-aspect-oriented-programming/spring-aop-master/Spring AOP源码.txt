源码分析入口: Spring AOP
AnnotationConfigApplicationContext.AnnotationConfigApplicationContext(Class<?>... componentClasses)
AbstractApplicationContext.refresh()
  AbstractApplicationContext.finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory)
  DefaultListableBeanFactory.preInstantiateSingletons()

AbstractBeanFactory.getBean(String name)
AbstractBeanFactory.doGetBean(name, null, null, false);
   DefaultSingletonBeanRegistry.getSingleton(beanName);
   AbstractBeanFactory.createBean()
      // 下面的方法返回了代理对象
      AbstractAutowireCapableBeanFactory.doCreateBean(beanName, mbdToUse, args)
      AbstractAutowireCapableBeanFactory.initializeBean(beanName, exposedObject, mbd);
      AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
         AbstractAutoProxyCreator.postProcessBeforeInstantiation()
         AbstractAutoProxyCreator.createProxy()
         proxyFactory.getProxy(classLoader);
         // 两种代理模式的使用

TODO: AOP解析切面时为什么要加缓存? 但是事务不加缓存 ?
源码位置 > BeanFactoryAspectJAdvisorsBuilder
1. AOP解析切面源码功能中传入的是Object对象，表示从容器中获取所有组件的名称，然后逐一遍历，加缓存是为了提高性能
2. 事务模块的功能是直接容器中获取Adviser类型，选择范围小，不需要添加缓存