@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited 标明可以从super class上查找注解
@SpringBootConfiguration
    > @EnableAutoConfiguration
       > @Import({AutoConfigurationImportSelector.class})
          > spring-boot-autoconfigure-xxx.RELEASE\META-INF\spring.factories 最终读取文件的位置

AutoConfigurationImportSelector >> selectImports() 源码的实现

    protected AutoConfigurationImportSelector.AutoConfigurationEntry
      getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
      if (!this.isEnabled(annotationMetadata)) {
          return EMPTY_ENTRY;
      } else {
          AnnotationAttributes attributes = this.getAttributes(annotationMetadata);
          List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
          去除读取文件中的重复数据
          configurations = this.removeDuplicates(configurations);
          搜集是否有自定义需要排除的装配
          通过@SpringBootApplication(excludeName = {})来设置
          Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);
          this.checkExcludedClasses(configurations, exclusions);
          configurations.removeAll(exclusions);
          多虑到没有导入的jar包，从读取的自动装配配置数据中排除
          configurations = this.getConfigurationClassFilter().filter(configurations);
          this.fireAutoConfigurationImportEvents(configurations, exclusions);
          return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);
      }
    }

    protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
      List<String> configurations = SpringFactoriesLoader.loadFactoryNames(
         this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
      Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories.
         If you are using a custom packaging, make sure that file is correct.");
      return configurations;
    }
